* 최소 공통 조상 (Lowest Common Ancestor, LCA) 알고리즘
*** 1. 가장 간단한 로직의 Worst: O(n)

 1) 모든 노드에 대해 depth 를 계산
   - DFS 수행

 2) 최소 공통 조상을 찾을 두 노드에 대해
   - 두 노드의 depth 를 동일하게 맞춤
     (depth 가 더 깊은 노드를 다른 한쪽 노드와 같아질때까지 위로 올림)
   - 두 노드의 부모가 같아질 때까지,
     반복적으로 두 노드를 부모 방향으로 거슬러 올라감



*** 2. 부모 노드로 2^k 칸씩 거슬러 올라가는 로직: O(log n)
 - 메모리를 조금 더 사용하여,
   각 노드의 2^i 번째 부모 노드를 저장
 - DP or 세그먼트 트리 이용
 e.g. 2^0 번째 부모: 1칸 위의 부모
      2^1 번째 부모: 2칸 위의 부모
      2^2 번째 부모: 4칸 위의 부모
      ...

 1) 모든 노드에 대해 depth 와 2^i 번째 부모를 저장
   - DFS: 각 노드의 depth 저장, 각 노드의 직계 부모(2^0번째 부모) 저장
   - DP: Sparse Table에 각 노드의 2^i 번째 부모 저장
     => int[][] parent = new int[n][21];
	(n: 트리 노드 개수, 21: 깊이 20 정도면, 왠만한 트리는 커버)
        parent[nodeIdx][i]: 노드의 2^i 번째 부모,
        parent[nodeIdx][i + 1] == parent[ parent[nodeIdx][i] ][i]
        : 2^(i+1) = 2 x 2^i = 2^i + 2^i 이용,
          노드의 2^(i+1) 번째 부모
		== (노드의 2^i 번째 부모)의 2^i 번째 부모
     => 트리의 노드 개수가 n 이면,
        메모리 4 x (n log n) byte (int 형 기준)

 2) 최소 공통 조상을 찾을 두 노드에 대해
   - 두 노드의 depth 를 동일하게 맞춤
     (depth 가 더 깊은 노드를 다른 한쪽 노드와 같아질때까지 위로 올림)
     Trick) 두 노드를 node1, node2 라고 하면,
            node2가 더 깊은 노드가 되도록, 필요시 n1과 n2를 swap
   - 두 노드의 부모가 같아질 때까지,
     반복적으로 두 노드를 부모 방향으로 거슬러 올라감

     !! 노드 이동시, 이동 가능한 최대 큰 칸부터 이동
        e.g. 13칸 위로 이동해야 하는 경우,
	     8칸 => 4칸 => 2칸 => 1칸 씩 이동
